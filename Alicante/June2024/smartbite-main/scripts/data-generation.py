"""
# Program for incorporating OpenFoodFacts into the project
This program describes how the JSON has been achieved by collecting the nutritional information of the ingredients of each dish, averaging and incorporating them into the JSON file that collects the information about each meal.

Originally, the JSON had been generated by ChatGPT. This program is responsible for adding the nutritional information of the ingredients of each dish using the OpenFoodFacts database.

Implementation by: Javier Maciá Sempere (https://github.com/Javier-Macia)

Check the source of the dataset: https://world.openfoodfacts.org/data
"""

# We import the necessary libraries.
import pandas as pd
import dask.dataframe as dd
import json

def get_average_nutrition(ddf: dd.DataFrame , ingredient: str) -> pd.Series:
    """Function to get the average nutritional values of an ingredient in the Dask DataFrame

    Args:
        ddf (dd.DataFrame): Dask DataFrame with nutritional information of foods
        ingredient (str): Name of the ingredient to search for

    Returns:
        pd.Series: Average nutritional values of the ingredient
    """
    # We filter the Dask DataFrame by the ingredient name.
    # This way, we will only be left with the rows that contain the ingredient in their name.
    filtered = ddf[ddf['generic_name'].str.contains(ingredient, case=False, na=False)]
    
    # Select nutritional columns
    nutrition_columns = ['energy_100g', 'sugars_100g', 'fiber_100g', 'fat_100g', 'proteins_100g', 'carbohydrates_100g']
    
    # Calculate the average values
    average_nutrition = filtered[nutrition_columns].mean().compute()
    
    return average_nutrition

def get_recipe_nutrition(ddf: dd.DataFrame, recipe: dict) -> pd.Series:
    """Function to obtain the nutritional values of a recipe

    Args:
        ddf (dd.DataFrame): Dask DataFrame with nutritional information of foods
        recipe (dict): Recipe with ingredients and portion
        
    Returns:
        pd.Series: Nutritional values of the recipe
    """
    ingredients = recipe['ingredients']
    portion_size = recipe['portion']
    
    total_nutrition = pd.Series(0, index=['energy_100g', 'sugars_100g', 'fiber_100g', 'fat_100g', 'proteins_100g', 'carbohydrates_100g'])
    count = 0
    
    # For each ingredient in the dish, we calculate the average nutritional values
    for ingredient in ingredients:
        average_nutrition = get_average_nutrition(ddf, ingredient['name'])
        # If the ingredient has no nutritional values, we do not count it
        if not average_nutrition.isnull().any():
            total_nutrition += average_nutrition * ingredient['proportion']
    
    # Adjust nutritional values ​​according to serving
    multiplier = portion_size / 100
    recipe_nutrition = total_nutrition * multiplier
    
    return recipe_nutrition

# We define the expected data types in the columns to avoid conflicts when operating on the data.
dtypes = {
    'abbreviated_product_name': 'object',
    'additives_en': 'object',
    'additives_tags': 'object',
    'allergens': 'object',
    'brand_owner': 'object',
    'cities_tags': 'object',
    'code': 'object',
    'emb_codes': 'object',
    'emb_codes_tags': 'object',
    'first_packaging_code_geo': 'object',
    'generic_name': 'object',
    'last_updated_t': 'float64',
    'manufacturing_places': 'object',
    'manufacturing_places_tags': 'object',
    'no_nutrition_data': 'object',
    'owner': 'object',
    'packaging': 'object',
    'packaging_en': 'object',
    'packaging_tags': 'object',
    'packaging_text': 'object',
    'purchase_places': 'object',
    'serving_size': 'object',
    'stores': 'object',
    'traces': 'object',
    'traces_en': 'object',
    'traces_tags': 'object',
    'additives_n': 'object',
    'cities': 'object',
    'nutriscore_score': 'object',
    'serving_quantity': 'object'
}

# We read the CSV file. Openfoodfacts.data.csv is an 8gb file and, for that reason,
# we use dask to read it. The delimiter is a tab.
# ---------------IMPORTANT----------------
# Because the file is very large, it has not been uploaded to Github. Therefore, it must be downloaded and placed in the data folder.
ddf = dd.read_csv('../openfoodfacts-implementation/data/openfoodfacts.data.csv', delimiter='\t' ,dtype=dtypes)

# We load the JSON with the old food information 
with open('../openfoodfacts-implementation/data/.old/food_info.json') as f:
    food_info = json.load(f)
    
# Calculate nutritional values ​​for each recipe in the JSON. It might take a while.
for recipe_name, recipe_info in food_info.items():
    nutrition = get_recipe_nutrition(ddf, recipe_info)
    food_info[recipe_name]['nutrition'] = nutrition.to_dict()

# We look for those cases in which the values ​​of 'energy_100g',
# 'sugars_100g', 'fiber_100g', 'fat_100g', 'proteins_100g' and 'carbohydrates_100g'
# be, all, 0. If so, the values ​​that had been obtained from ChatGPT will be taken
# and will be replaced by these.
for recipe_name, recipe_info in food_info.items():
    if recipe_info['nutrition']['energy_100g'] == 0 and recipe_info['nutrition']['sugars_100g'] == 0 and recipe_info['nutrition']['fiber_100g'] == 0 and recipe_info['nutrition']['fat_100g'] == 0 and recipe_info['nutrition']['proteins_100g'] == 0 and recipe_info['nutrition']['carbohydrates_100g'] == 0:
        print(recipe_name, recipe_info['nutrition'])
        recipe_info['nutrition']['sugars_100g'] = recipe_info['sugars']
        recipe_info['nutrition']['fiber_100g'] = recipe_info['fiber']
        recipe_info['nutrition']['fat_100g'] = recipe_info['fat']
        recipe_info['nutrition']['proteins_100g'] = recipe_info['protein']
        recipe_info['nutrition']['carbohydrates_100g'] = recipe_info['carbohydrates']
        # The energy had been obtained from ChatGPT, but can be calculated with the following operation to give more precise information: kcal = 9 x fats + 4 x carbohydrates + 4 x proteins
        recipe_info['nutrition']['energy_100g'] = recipe_info['nutrition']['fat_100g']*9 + recipe_info['nutrition']['carbohydrates_100g']*4 + recipe_info['nutrition']['proteins_100g']*4
        print(recipe_name, recipe_info['nutrition'])
        
# We take into account what is generated by ChatGPT to calculate nutritional values
# We do this in each of the dishes and we do it in order to try to have more precise information.
# Energy is not taken into account since ChatGPT has given data that does not fit the aforementioned formula (kcal = 9 x fats + 4 x carbohydrates + 4 x proteins).
# For this reason, its value is recalculated.
for recipe_name, recipe_info in food_info.items():
    recipe_info['sugars'] = (recipe_info['nutrition']['sugars_100g'] + recipe_info['sugars'])/2 * (recipe_info['portion'] / 100)
    recipe_info['fiber'] = (recipe_info['nutrition']['fiber_100g'] + recipe_info['fiber'])/2 * (recipe_info['portion'] / 100)
    recipe_info['fat'] = (recipe_info['nutrition']['fat_100g'] + recipe_info['fat'])/2 * (recipe_info['portion'] / 100)
    recipe_info['protein'] = (recipe_info['nutrition']['proteins_100g'] + recipe_info['protein'])/2 * (recipe_info['portion'] / 100)
    recipe_info['carbohydrates'] = (recipe_info['nutrition']['carbohydrates_100g'] + recipe_info['carbohydrates'])/2 * (recipe_info['portion'] / 100)
    
    # We round nutritional values ​​so that there are no decimals
    recipe_info['sugars'] = round(recipe_info['sugars'])
    recipe_info['fiber'] = round(recipe_info['fiber'])
    recipe_info['fat'] = round(recipe_info['fat'])
    recipe_info['protein'] = round(recipe_info['protein'])
    recipe_info['carbohydrates'] = round(recipe_info['carbohydrates'])
    recipe_info['kcal'] = round(recipe_info['kcal'])
    
# We remove all "nutrition" from food information
for recipe_name, recipe_info in food_info.items():
    del recipe_info['nutrition']
    
# We save the JSON with the food information from OpenFoodFacts
with open('../datasource/food_info/food_info.json', 'w') as f:
    json.dump(food_info, f, indent=4)
